 # Лабораторная работа 3

 **Выполнил:** Батаргин Егор Александрович

 **Группа:** P3332

 # В чем смысл?

 Это комбинационный парсер, который использует базовый парсер. Основная задача: из установленного формата преобразовать данные в соответствующий тип данных и сохранить в программе. Сейчас у нас обрабатывается два формата: JSON и CSV. 

Как это работает:
  - У нас есть JSON-формат.
  - Программа читает данные.
  - Устанавливает тип.
  - При необходимости разделяет.
  - И сохраняет, но уже в новом виде.
  - У нас есть CSV-формат.
  - Программа читает строчку.
  - Разделяет, например, по ;.
  - И сохраняет как набор данных.

# А теперь подробнее

**Program**

Начнём с основного файла — Program.fs. В нём содержится программа с некоторыми данными для JSON-парсера и CSV-парсера, которые используются для ручной проверки работоспособности программы.

В 12-й строке мы видим метод `joinValue`, который возвращает соответствующий тип данных. Если же возвращается значение `None`, это свидетельствует о возникновении ошибки в парсере.

Далее следует проверка CSV-парсера. В 19-й строке мы вызываем метод `parserCsvLine`, который возвращает разделённую строку CSV. Разделителем в этом случае служит стандартный символ `;`.
```
    open System
    open JsonParser
    open CsvParser
    open Parser
    
    [<EntryPoint>]
    let main argv =
        
        printfn "Тесты JSON:"
        let jsonTestCases = ["null"; "true"; "-123.45"; "\"Hello, F#\""]
        jsonTestCases |> List.iter (fun input ->
            match runParser jsonValue input with
            | Some(result, _) -> printfn "Парсинг JSON: %s -> %A" input result
            | None -> printfn "Ошибка парсинга JSON: %s" input)
    
        
        printfn "\nТест CSV:"
        let csvInput = "val1;val2;val3\n"
        match runParser parseCsvLine csvInput with
        | Some(result, _) -> printfn "Парсинг CSV: %A" result
        | None -> printfn "Ошибка парсинга CSV"

    0
```

Если инетересно, то предлагаю посмотреть, как конкретно работают эти методы

**Parser**

```

module Parser


type Parser<'T> = Parser of (string -> ('T * string) option)


let runParser (Parser p) input = p input


let returnP x = Parser(fun input -> Some(x, input))


let bindP p f =
    Parser(fun input ->
        match runParser p input with
        | Some(result, rest) -> runParser (f result) rest
        | None -> None)


let (>>=) = bindP


let mapP f p = p >>= (f >> returnP)


let (<|>) p1 p2 =
    Parser(fun input ->
        match runParser p1 input with
        | Some _ as result -> result
        | None -> runParser p2 input)


```

`Parser<'T>` — идет определение парсера, который принимает строку и возвращает результат работы и остаток строки. `'T` — говорит о том, что тип результата универсален.

`runParser` — запускает парсер, передавая на вход строку.

`returnP` — это так называемый фиксированный парсер. Он всегда успешно возвращает заданное значение, не требуя входа. Например, используется в `CsvParser.fs`, чтобы вернуть результат парсера в виде списка разделенных элементов.

`bindP` — функция, которая позволяет соединять парсеры. Например, у нас сработал парсер `p` первый раз, вернул остаток строки, и тогда запускается новый `f` с остатком строки.

`let (>>=) = bindP` — инфиксный оператор связывания. Такая штучка сделана для удобства. Это повышает читаемость, но в основе использует выше упомянутую функцию.

`mapP` — позволяет применить написанную функцию к результату работы парсера.

`<|>` — позволяет запустить парсер второй, если первый неудачен. Например, мы попытались разобрать данные как число, не вышло, разбираем как строчку. (`let parse = pNumber <|> pString`)

Хух, ну вроде определилось, что тут за что отвечает.

**BaseParsers**

Это набор «строительных» блоков для создания парсера. Здесь реализованы все необходимые функции для реализации парсеров.

- `satisfy` — парсер для символов, которые удовлетворяют заданному условию.  Принимает функцию-предикат и пытается найти символ, который удовлетворяет этому предикату. Функция-предикат — это функция, которая принимает одно или несколько значений, а возвращает логическое.
- `pChar` — парсер для конкретного символа. Здесь используется `satisfy` с предикатом `(=) c` который проверяет, равен ли первый символ символу `c`.
- `pString` — парсер для конкретной строки. Проверяет, начинается ли строка с подстроки `s`. Если да, то возвращает распарсенную строку `s` и оставшуюся часть `rest`, иначе возвращает `None`.
- `many` — парсер для нулевого или более повторений другого парсера. Пытается применить парсер несколько раз и возвращает либо список распарсенных элементов, либо пустой список.
- `many1` — парсер для одного или более повторений другого парсера. Это более строгий вид парсера, который требует хотя бы одну успешную работу парсера `p` и в худшем случае вернет не пустой список, а `None`.

```
module BasicParsers
open Parser


let satisfy predicate =
    Parser(fun input ->
        match input with
        | "" -> None
        | _ ->
            let c = input.[0]
            if predicate c then Some(c, input.[1..])
            else None)


let pChar c = satisfy ((=) c)


let pString (s: string) =
    Parser(fun input ->
        if input.StartsWith(s) then Some(s, input.[s.Length..])
        else None)


let rec many p =
    (p >>= fun x -> many p >>= fun xs -> returnP (x :: xs))
    <|> returnP []


let many1 p = p >>= fun x -> many p >>= fun xs -> returnP (x :: xs)
```

**JsonParser**

По названию можно догадаться, что здесь речь идет о прасере JSON-значений: числа (цеы, вещественные, положительные, отрицательные), строк, null, логические

Посмотрим на код

```
module JsonParser
open Parser
open BasicParsers


let whitespace = many (satisfy System.Char.IsWhiteSpace) |> mapP ignore


let jNull = pString "null" |> mapP (fun _ -> null: obj)


let jBool =
    (pString "true" |> mapP (fun _ -> true))
    <|> (pString "false" |> mapP (fun _ -> false))


let jNumber =

let jString =
    let quote = pChar '"'
    let strChar = satisfy ((<>) '"')
    quote >>= fun _ ->
    many strChar >>= fun chars ->
    quote >>= fun _ ->
    returnP (chars |> List.toArray |> System.String)


let jsonValue =
    (jNull |> mapP box)
    <|> (jBool |> mapP box)
    <|> (jNumber |> mapP box)
    <|> (jString |> mapP box)
```

Здесь все виды парсеров запускаются в объединенном парсере `jsinValue`. Данная функция использует знакомую операцию `<|>`. Это позволяет нам прогнать одно значение по всем парсерам, чтобы определить тип данных.

Парсер `jBool` позволяет преобразовать логическое значение json в логическое значение в программе. Тут используется функция `pString`, которая будет разобрана позже. Она реализована в `BasicParsers`. Если у нас «true», то возвращаем true и т.д.

`whitespace` — парсер пробельных символов, чтобы их игнорировать.

`jNull` — если json-значение null, то вернет в программу null.

`jNumber` — парсер чисел. Он проверяет, есть ли знак минус, цифра или точка, затем парсит в список элементов и с помощью `mapP` преобразует в одно значение float. И такой парсер обработает и отрицательные значения, и положительные, и целые, и дробные.

`jString` — парсер строк. Как он работает:
  - `pChar '"'` — находит символ кавычки " в начале и в конце строки.
  - `satisfy ((<>) '"')` — позволяет парсить все символы, кроме кавычек.
  - `many strChar` — парсит все символы внутри строки (пока не встречается кавычка).
  - Когда строка распарсена, она преобразуется в тип `string` с помощью `returnP`.
Это основные моменты парсера.
**CsvParser**

Потоковый парсер csv-строки. Его задача простая: разделить данные между собой. И чаще всего в csv файлах для разделения столбцов используют знак `;`, поэтому этот знак тут как рзаделитель.

```

let parseCell =
    many (satisfy (fun c -> c <> ';' && c <> '\n'))
    |> mapP (fun chars -> chars |> List.toArray |> System.String)


let parseCsvLine =
    let comma = pChar ';'
    parseCell >>= fun firstCell ->
    many (comma >>= fun _ -> parseCell) >>= fun restCells ->
    returnP (firstCell :: restCells)
```


`parseCell` — этот парсер нужен для того, чтобы распознавать отдельную ячейку, проверяя, что в ней не должно быть `;` или `\n`. Тогда идет запись в результат.

И эта функция используется в `parseCsvLine`, которая предназначена для приема и парсинга всей строки. Результат собирается в список подстрок. Например, `value1;value2;value3` -> `["value1", "value2", "value3"]`.



